#include "val.h"

/**
 * @defgroup        val Val
 *
 *                  Used by the node when data is received on the
 *                  UDP socket. The data is sent as a buffer and
 *                  converted to fit the PDU-struicts and stored
 *                  in the hashtable.
 *
 * @author          dv18mln dv18mfg
 * @see             node.h
 * @{
 */

/**
 *                  The function is passed a buffer containing
 *                  the SSN, name and email to be inserted into the
 *                  hashtable.
 *                  The index of where the data should be saved
 *                  is generated by the hashfunction by using the
 *                  given SSN. If the generated index is within
 *                  the nodes range, the rest of the data can be
 *                  extracted from the buffer and inserted into the
 *                  hashtable. If, instead, the index is above the
 *                  available range the buffer is sent to the node's
 *                  successor. If the index is beneath the available
 *                  range of the node, the data is sent to the node's
 *                  predecessor. Communication with other nodes are
 *                  done over TCP.
 *
 * @param pfds      The poll file descriptors referring to the created
 *                  sockets.
 * @param table     Hashtable to store the data.
 * @param buffer    Buffer sent over UDP containing the data.
 * @param size      Size of the buffer.
 * @param range_start   Beginning of the nodes index.
 * @param range_end     End of the nodes index.
 *
 * @see             hash.c
 */
void insert_val(struct pollfd pfds[4], struct h_table *table,
                uint8_t *buffer, int size, uint8_t range_start,
                uint8_t range_end)
{

    fprintf(stdout, "[Q9] Got insert request.\n");

    uint8_t ssn[SSN_LENGTH];

    for (int i = 0; i < SSN_LENGTH; i++)
    {
        ssn[i] = buffer[1 + i];
    }

    uint8_t index = hash_ssn(ssn);

    if (index >= range_start && index <= range_end)
    {
        fprintf(stdout, "Index: %d\n", index);
        uint8_t name_length = buffer[13];

        uint8_t name_temp[name_length];
        for (int j = 0; j < name_length; j++)
        {
            name_temp[j] = buffer[14 + j];
        }

        uint8_t email_length = buffer[14 + name_length];

        uint8_t email_temp[email_length];
        for (int k = 0; k < email_length; k++)
        {
            email_temp[k] = buffer[14 + name_length + 1 + k];
        }

        int insert = htable_insert(ssn,
                                   name_length,
                                   name_temp,
                                   email_length,
                                   email_temp,
                                   index - range_start,
                                   table);
        if (insert == 0)
        {
            fprintf(stdout, "Inserted.\n");
        }
    }
    else
    {

        int buffer_size = 15 + buffer[13] + buffer[14 + buffer[13]];

        uint8_t temp[buffer_size];
        for (int i = 0; i < buffer_size; i++)
        {
            temp[i] = buffer[i];
        }

        if (index < range_start && pfds[3].events != 0)
        {
            fprintf(stdout, "Out of index, sending to predecessor.\n");
            pfds[3].events = POLLOUT;
            poll(&(pfds[3]),1,0);
            int res = send(pfds[3].fd, &temp, sizeof(temp), 0);
            if (res < 0)
            {
                perror("Sending to predecessor");
            }
        }
        else if (index > range_end && pfds[1].events != 0)
        {
            fprintf(stdout, "Out of index, sending to successor.\n");
            pfds[1].events = POLLOUT;
            poll(&(pfds[1]),1,0);
            int res = send(pfds[1].fd, &temp, sizeof(temp), 0);
            if (res < 0)
            {
                perror("Sending to predecessor");
            }
        }
    }
}

/**
 *                  Generates the index of the given SSN, if the
 *                  index is within the nodes range, the hashtable is searched.
 *                  If the index is outside the node's index-range,
 *                  the data is sent to the next node over TCP.
 *
 * @param pfds      The poll file descriptors referring to the created
 *                  sockets.
 * @param table     Hashtable to store the data.
 * @param buffer    Buffer sent over UDP containing the data.
 * @param size      Size of the buffer.
 * @param range_start   Beginning of the nodes index.
 * @param range_end     End of the nodes index.
 *
 * @see node_lookup
 */

void lookup_val(struct pollfd pfds[4], struct h_table *table, uint8_t *buffer, int size, uint8_t range_start, uint8_t range_end)
{

    fprintf(stdout, "[Q9] Got lookup request.\n");

    struct VAL_LOOKUP_PDU request;
    request.type = buffer[0];

    uint8_t ssn[12];
    for (int i = 0; i < 12; i++)
    {
        ssn[i] = buffer[i + 1];
    }

    int index = hash_ssn(ssn);

    request.sender_address = buffer[13] | buffer[14] << 8 |
                             buffer[15] << 16 | buffer[16] << 24;
    request.sender_port = buffer[18] | buffer[17] << 8;

    if (index >= range_start && index <= range_end)
    {
        node_lookup(pfds, request, ssn, table, range_start);
    }
    else
    {

        int buffer_size = 19;

        uint8_t temp[buffer_size];
        for (int i = 0; i < buffer_size; i++)
        {
            temp[i] = buffer[i];
        }

        if (index < range_start && pfds[3].events != 0)
        {
            fprintf(stdout, "Sending lookup to predecessor\n");
            pfds[3].events = POLLOUT;
            poll(&(pfds[3]),1,0);
            int res = send(pfds[3].fd, &temp, sizeof(temp), 0);
            if (res < 0)
            {
                perror("Sending to predecessor");
            }
        }
        if (index > range_end && pfds[1].events != 0)
        {
            fprintf(stdout, "Sending lookup to successor\n");
            pfds[1].events = POLLOUT;
            poll(&(pfds[1]),1,0);
            int res = send(pfds[1].fd, &temp, sizeof(temp), 0);
            if (res < 0)
            {
                perror("Sending to successor");
            }
        }
    }
}

/**
 *                  If a matching SSN could be found, the PDU with SSN, name
 *                  and email are converted to a buffer and a response is sent
 *                  to the client over UDP.
 *
 * @param pfds      The poll file descriptors referring to the created
 *                  sockets.
 * @param request   Lookup pdu containing the senders/clients ip-address.
 * @param ssn       Social security number to be looked up.
 * @param table     Hashtable to store the data.
 * @param range_start   Beginning of the nodes index.
 */
void node_lookup(struct pollfd pfds[4], struct VAL_LOOKUP_PDU request, uint8_t *ssn, struct h_table *table, uint8_t range_start)
{

    struct sockaddr_in cli_addr;
    cli_addr.sin_family = AF_INET;
    cli_addr.sin_port = htons(request.sender_port);
    cli_addr.sin_addr.s_addr = request.sender_address;

    struct VAL_LOOKUP_RESPONSE_PDU response;
    response.type = 103;

    int index = hash_ssn(ssn);

    int lookup = htable_lookup(ssn,
                               &response.name_length,
                               &response.name,
                               &response.email_length,
                               &response.email,
                               index - range_start,
                               table);
    if (lookup == 1)
    {
        fprintf(stdout, "Could not find entry\n");
        response.email_length = 0;
        response.email = 0;
        response.name = 0;
        response.name_length = 0;
    }
    else
    {
        fprintf(stdout, "entry found, sending to client...\n");
    }
    uint8_t buffer[15 + response.name_length + response.email_length];
    buffer[0] = response.type;

    for (int j = 0; j < SSN_LENGTH; j++)
    {
        buffer[1 + j] = ssn[j];
    }
    buffer[13] = response.name_length;
    for (int i = 0; i < response.name_length; i++)
    {
        buffer[14 + i] = response.name[i];
    }

    buffer[14 + response.name_length] = response.email_length;

    for (int k = 0; k < response.email_length; k++)
    {
        buffer[14 + response.name_length + 1 + k] = response.email[k];
    }
    int res = sendto(pfds[0].fd, &buffer, sizeof(buffer), 0,
                     (struct sockaddr *)&cli_addr, sizeof(cli_addr));
    if (res == -1)
    {
        perror("Could not send response...");
    }
}

/**
 *                  Remove request sent from the client containing
 *                  a SSN. If the index is outside the nodes range, the
 *                  request is forwarded. If a matching SSN was found in
 *                  hashtable it is removed.
 *
 * @param pfds      The poll file descriptors referring to the created
 *                  sockets.
 * @param table     Hashtable to store the data.
 * @param buffer    Buffer sent over UDP containing the data.
 * @param size      Size of the buffer.
 * @param range_start   Beginning of the nodes index.
 * @param range_end     End of the nodes index.
 */
void remove_val(struct pollfd pfds[4], struct h_table *table, uint8_t *buffer, int size, uint8_t range_start, uint8_t range_end)
{

    fprintf(stdout, "[Q9] Got remove request.\n");
    
    int type = buffer[0];

    uint8_t ssn[12];
    for (int i = 0; i < 12; i++)
    {
        ssn[i] = buffer[i + 1];
    }
    int index = hash_ssn(ssn);

    if (index >= range_start && index <= range_end)
    {
        int remove = htable_remove(ssn, index - range_start, table);

        if (remove == 0)
        {
            fprintf(stdout, "Removed!\n");
        }
        else
        {
            fprintf(stdout, "Could not find entry to remove.");
        }
    }
    else
    {

        int buffer_size = 13;

        uint8_t temp[buffer_size];
        for (int i = 0; i < buffer_size; i++)
        {
            temp[i] = buffer[i];
        }
        if (index < range_start && pfds[3].events != 0)
        {
            fprintf(stdout, "Sending remove request to predecessor\n");
            pfds[1].events = POLLOUT;
            poll(&(pfds[1]),1,0);
            int res = send(pfds[3].fd, &temp, sizeof(temp), 0);
            if (res < 0)
            {
                perror("Sending to predecessor");
            }
        }
        if (index > range_end && pfds[1].events != 0)
        {
            fprintf(stdout, "Sending remove request to successor\n");
            pfds[3].events = POLLOUT;
            poll(&(pfds[3]),1,0);
            int res = send(pfds[1].fd, &temp, sizeof(temp), 0);
            if (res < 0)
            {
                perror("Sending to successor");
            }
        }
    }
}

/**@}*/
